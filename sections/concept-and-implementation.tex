The following chapter will describe the software that was implemented as part of this thesis. The software is supposed to read in an \gls{bpmn}2.0 Diagram and return a list of suggestions how this BPMN can be improved according to the best-practices described in the first chapters.
\section{Software Architecture}
The Software was implemented as an Spring Boot Server\cite{spring-boot} Application. The software was developed using git\cite{git} as version control system and the git project is available as an open source project on \url{https://github.com/dsunaric/epms-service}.\\~\\

This software is implemented using maven\cite{maven} as a build-tool, therefore software artifacts can be added to the local repository using the command \verb|mvn install|. This also generates the API sources into the \verb|target| directory. After that the packaged .jar file can be run using the command \verb|java -jar target/*.jar|. 


\subsection{BPMN Processing}
For reading in and processing the BPMN models the Camunda-Model-API\cite{camunda-model-api} was used. The reason for that was the detailed documentation and better usability compared to using an XML parser. The Camunda Model API is able to process most BPMN 2.0 elements. A list of supported elements can be found in the \textit{instance} package\cite{camunda-model-api-spoorted-elements}.
% BPMN 2.0
% cmaunda BPMN model API
\newpage
\subsection{Folder structure}~\\
The following visualizes and describes the important parts of the projects folder structure:
\dirtree{%
	.1 epms-service.
	.2 src.
		.3 main.
			.4 java.
				.5 at.
					.6 epms.
						.7 api\DTcomment{contains implemented API}.
						.7 entity.
						.7 mapper.
						.7 service\DTcomment{contains suggestion logic}.
							.8 validator\DTcomment{contains validators for the specified best-practices}.
			.4 resources.
				.5 api\DTcomment{contains API specification}.
				.5 config\DTcomment{contains Spring Boot configuration}.
			.4 webapp\DTcomment{contains generated sources for potential clients}.
	.2 target\DTcomment{contains executable .jar file after build} .
}

\section{Interface}
The API was designed and developed using OpenAPI and Swagger\cite{swagger}. The OpenAPI definition is written in one \textit{.yaml} file which is located in the folder\\ \verb|epms-service/src/main/resources/api|.

After Starting the Software, the API description is accessible on \\ \verb|localhost:8080/documentation/v3/api-docs| and can directly be used for code generation by potential frontend applications. 

The application has only one REST-Endpoint, \verb|GET /suggestions|. This endpoint has the process model as request body and returns a list of \textbf{AppliedRules} Objects. 

One \textbf{AppliedRule} object has the following attributes:
\begin{itemize}
	\item \textbf{title}: The title of the applied Rule
	\item \textbf{description}: The description of the rule. Explains when the Rule applies.
	\item \textbf{details}: Explains details about the rule and gives explanation about the effected elements.
	\item \textbf{effectedElements}: A list of elements that violate this rule. The id, name and type (event or task) of the effected element is returned.
\end{itemize} 
\section{Suggestions for improvement}
This section describes a set of possible suggestions for improving a BPMN Model. Not all of those rules where implemented as some are not suitable for automation or would be beyond the scope of this thesis. 
\subsection{Comply with Naming Conventions}
BPMN models, no matter if conceptual or executable, should meet naming conventions as it is described in chapter 2 \ref{naming}. 
Since natural language processing would go beyond the scope of this thesis and naming conventions apply to not only executable BPMN, this suggestion for improvement was not automated in the context of this thesis.
\subsection{Extend automation boundaries}
% TODO cite first two chapters

\subsection{Complete the process model}
% TODO cite first two chapters

\subsection{Value Added Analysis}
% TODO cite first two chapters

\subsection{No Manual Tasks}
% TODO cite first two chapters
As describes in chapter 2 \ref{manual} Manual Tasks should not be part of an executable BPMN diagram and should if possible be automated using service tasks or, if that is not possible, be replaced by user tasks. 

Manual tasks are identified by the software the returned effected elements represent a list of manual tasks in the given diagram.

\subsection{No two consecutive Tasks handled by the same resource}
Two task that are executed one after the other should be merged, if they have the same enitity executing the task. As described in chapter 2, bringing the model to an adequate granularity level\ref{granulartity} minimizes handovers and overhead. In case of User tasks this means the same usergroup is executing this task. Automated Tasks that follow each other should also always be merged to minimize flownodes.

The software recognizes such consective tasks return a list of effected elements that represent the tasks that can be merged with its direct successor. In case that three or more tasks can be merged, this algorithm will return every task that can be merged with its successor on its own. Therefore if ``task1`` , ``task2`` and ``task3`` can be merged all together, the algorithm will return ``task2`` and ``task3`` as effected elements.
\subsection{Inclusive Gateways over combining parallel and exclusive Gateways}
In order to save flownodes, inclusive gateways should be used instead of a parallel gateway followed by one or more exclusive gateways. An example for this kind of pattern is shown in \ref{fig:example-GW}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\columnwidth]{graphics/exclusive-suggestion-1}
	\caption{Example for a parallel gateway followed by one or more exclusive gateways} 
	\label{fig:example-GW} 
\end{figure}

The software applies this rule whenever a parallel gateways is followed by one or more exclusive gateways. The returned effected elements are a list of parallel gateways that are followed by one or more exclusive gateways in the given diagram. In the example shown in  \ref{fig:example-GW}, the returned element would be \textit{GW1} and the change to comply with this rule would be shown in \ref{fig:example-GW-fix}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\columnwidth]{graphics/exclusive-suggestion-2}
	\caption{change necessary for the process in \ref{fig:example-GW} so satisfy this rule} 
	\label{fig:example-GW-fix} 
\end{figure}
\subsection{Evaluate Suggestions Quantitative}
% TODO cite first two chapters